---
title: "branchmodel_numerical"
author: "Eric Kernfeld"
date: "March 30, 2017"
output: html_document
---

Building blocks for branchmodel calculations.

```{r}

# # Shitty little vector 2-norm shortcut
norm2 = function(x) { sqrt( sum( x*x ) ) }
distance_sq =  function( x, y ) sum(( x - y )*( x - y ))
  
# # Calculates the distance between `point` and the closest convex combination
# # of `tip1` and `tip2`, i.e. the closest vector of the form
# # `p*tip1 + q*tip2` where 0 <= p, q <= 1; p + q = 1.
setGeneric( "distance_to_line_segment", function( tip1, tip2, point, ... ) standardGeneric( "distance_to_line_segment" ) )
setMethod( "distance_to_line_segment", valueClass = "numeric",
          signature = signature( tip1 = "numeric", tip2 = "numeric", point = "numeric" ),
          function             ( tip1, tip2, point ) {

  if( all( tip1 == point ) | all( tip2 == point ) ){ return(0) }
  point_centered = ( point - tip2 )
  tip1_centered  = ( tip1  - tip2 )
  point_centered_scaled  = point_centered / norm2 ( point_centered )
  tip1_centered_scaled   = tip1_centered  / norm2 ( tip1_centered  )
  c_cos_theta = sum( tip1_centered_scaled * point_centered_scaled ) * norm2 ( point_centered )
  comp_parallel =  c_cos_theta * tip1_centered_scaled

  if( 0 < c_cos_theta && c_cos_theta < norm2 ( tip1_centered  )  ){
    comp_perp = point_centered - comp_parallel
    return ( norm2( comp_perp ) )
  } else {
    endpoint_diffs = c( norm2 ( point - tip2 ), norm2 ( point - tip1 ) )
    return ( min ( endpoint_diffs ) )
  }
})


# # Calculates the distance between `point` and the closest vector of the form
# # `a( tip1 - tip2 ) + tip2` where a >= 0. 
setGeneric( "distance_to_ray", function( tip1, tip2, point, ... ) standardGeneric( "distance_to_ray" ) )
setMethod( "distance_to_ray", valueClass = "numeric",
          signature = signature( tip1 = "numeric", tip2 = "numeric", point = "numeric" ),
          function             ( tip1, tip2, point ) {

  if( all( tip1 == point ) | all( tip2 == point ) ){ return(0) }
  point_centered = ( point - tip2 )
  tip1_centered  = ( tip1  - tip2 )
  point_centered_scaled  = point_centered / norm2 ( point_centered )
  tip1_centered_scaled   = tip1_centered  / norm2 ( tip1_centered  )
  c_cos_theta = sum( tip1_centered_scaled * point_centered_scaled ) * norm2 ( point_centered )
  comp_parallel =  c_cos_theta * tip1_centered_scaled
  if( 0 < c_cos_theta ){
    comp_perp = point_centered - comp_parallel
    return ( norm2( comp_perp ) )
  } else {
    endpoint_diffs = c( norm2 ( point - tip2 ), norm2 ( point - tip1 ) )
    return ( min ( endpoint_diffs ) )
  }
})

#' Remove the last few points from a principal curve.
#' 
#' The tricky part is the tag, which is not ordered the same way as the others.
#' It's like the output of order(<positions along curve>) in that `pc$s[pc$tag, ]` is smooth.
#' Since it indexes `pc$s`, if I remove `pc$s[45,]`, need to make sure `!any(pc$tag==45)`.
setGeneric( "princurve_truncate", function( pc, n_remove, ... ) standardGeneric( "princurve_truncate" ) )
setMethod( "princurve_truncate", valueClass = "principal.curve",
          signature = signature( pc = "principal.curve", n_remove = "numeric" ),
          function             ( pc, n_remove ) {
  keep = nrow(pc$s) - n_remove ; keep = 1:keep
  
  pc$lambda  = pc$lambda[keep]
  pc$s       = pc$s     [keep, ]
  pc$tag     = intersect(pc$tag, keep)
  return( pc )
})

#' Find a connected component of a directed graph.
#'
#' @param neighbors neighbors directly reachable from each vertex, so there is an edge from `i` to `neighbors[i, j]`.
#' (This is built for knn graphs, hence the weird representation.)
#' @param start_idx Algorithm starts here and searches outward.
get_connected_component = function( neighbors, start_idx ){
  outside_edges = start_idx
  conn_comp_idx = start_idx
  for( i in 1:nrow(neighbors) ){
    conn_comp_idx = union( conn_comp_idx, outside_edges )
    outside_edges = c( neighbors[ outside_edges, ] ) #Move out a layer
    outside_edges = setdiff( outside_edges, conn_comp_idx ) #exclude things already searched
    if(length(outside_edges)==0){break}
  }
  conn_comp_idx = union( conn_comp_idx, outside_edges )
  return( conn_comp_idx )
}

#' Find the closest pair of points, one in one class and the other in another class.
#'
bipartite_closest_pair = function( coords_1, coords_2 ){
  knn_mod = FNN::get.knnx( query = coords_1, data = coords_2, k = 1 )
  nearest_ind_1 = which.min(knn_mod$nn.dist)
  nearest_ind_2 = knn_mod$nn.index[nearest_ind_1, 1]
  nearest_coords = rbind( coords_1[nearest_ind_1, ], coords_2[nearest_ind_2, ])
  return( list( inds = c(nearest_ind_1, nearest_ind_2), 
                coords = nearest_coords, 
                distance = knn_mod$nn.dist[nearest_ind_1, 1]) )
}

#' Calls `kknn::specClust` with preprocessing to remove outliers and postprocessing to label them.
#' 
#' @value Atomic vector of length `nrow(data)` containing cluster labels.
#' @details This is an attempt to circumvent this ARPACK failure issue: https://github.com/KlausVigo/kknn/issues/7
kknn_specClust_outlier_removal = function( data, centers, nn = 7, ...){
  # remove outliers
  dist_to_nn = rowSums( FNN::get.knn( data = data, k = nn, algorithm = c( "cover_tree" ) ) $nn.dist )
  cutoff = mean( dist_to_nn ) + 2*sd( dist_to_nn )
  is_outlier = dist_to_nn > cutoff
    
  # Cluster
  cluster_mod = kknn::specClust(data[!is_outlier, ], centers = centers, nn = nn,  ...)
  labels = rep(NA, nrow(data))
  labels[!is_outlier] = cluster_mod$cluster
  
  # label outliers
  labels[is_outlier] = FNN::knn( test  = data[ is_outlier, ], 
                                 train = data[!is_outlier, ], 
                                 cl = labels[!is_outlier], 
                                 k = nn, algorith = "cover_tree" )
  assertthat::assert_that(!any(is.na(labels)))
  return(labels)
}
```
